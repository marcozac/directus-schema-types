package dst

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"

	"github.com/marcozac/directus-schema-types/schema"
	"github.com/marcozac/directus-schema-types/util"
)

// NewClient creates a new Directus client.
func NewClient(options ClientOptions) *Client {
	return &Client{
		client:  http.DefaultClient,
		options: options,
	}
}

type ClientOptions struct {
	// [REQUIRED]
	// BaseURL is the base URL for the Directus instance.
	BaseURL string

	// [REQUIRED]
	// Token is the authentication token for the client.
	// It must be generated by an admin user.
	Token string
}

// Client is a client for a Directus instance.
type Client struct {
	client  *http.Client
	options ClientOptions
}

// Snapshot writes a JSON representation of the Directus schema to the given
// writer.
func (c *Client) Snapshot(w io.Writer) error {
	return c.snapshot(json.NewEncoder(w))
}

// SnapshotPretty writes a pretty-printed JSON representation of the Directus
// schema to the given writer.
func (c *Client) SnapshotPretty(w io.Writer) error {
	enc := json.NewEncoder(w)
	enc.SetIndent("", "  ")
	return c.snapshot(enc)
}

func (c *Client) snapshot(enc *json.Encoder) error {
	s, err := c.GetSchema()
	if err != nil {
		return fmt.Errorf("get schema: %w", err)
	}
	return enc.Encode(s)
}

// GetSchema returns the schema of the Directus instance.
// Under the hood, it calls GetCollections, GetFields, and GetRelations.
func (c *Client) GetSchema() (*schema.Schema, error) {
	collections, err := c.GetCollections()
	if err != nil {
		return nil, fmt.Errorf("get collections: %w", err)
	}
	fields, err := c.GetFields()
	if err != nil {
		return nil, fmt.Errorf("get fields: %w", err)
	}
	relations, err := c.GetRelations()
	if err != nil {
		return nil, fmt.Errorf("get relations: %w", err)
	}
	return &schema.Schema{
		Collections: collections,
		Fields:      fields,
		Relations:   relations,
	}, nil
}

// GetCollections returns the list of collections in the Directus instance.
func (c *Client) GetCollections() ([]schema.Collection, error) {
	return get[schema.Collection](c, "/collections")
}

// GetFields returns the list of fields in the Directus instance.
func (c *Client) GetFields() ([]schema.Field, error) {
	return get[schema.Field](c, "/fields")
}

// GetRelations returns the list of relations in the Directus instance.
func (c *Client) GetRelations() ([]schema.Relation, error) {
	return get[schema.Relation](c, "/relations")
}

func (c *Client) get(endpoint string, cbs ...requestCallback) (*http.Response, error) {
	return c.do(http.MethodGet, endpoint, nil, cbs...)
}

type requestCallback func(*http.Request)

// do performs an HTTP request with the given method to the Directus endpoint.
// Optionally, it is possible to provide:
//   - body: an io.Reader to be sent as the request body
//   - cbs: a list of callbacks to modify the request before sending it
//
// If a callback is provided, it is called with the request. It is not required
// to set the "Authorization" header, as it is automatically set with the
// client's token and should be used for other purposes, like setting additional
// headers
func (c *Client) do(method, endpoint string, body io.Reader, cbs ...requestCallback) (*http.Response, error) {
	u, err := url.JoinPath(c.options.BaseURL, endpoint)
	if err != nil {
		return nil, fmt.Errorf("join %s endpoint path: %w", endpoint, err)
	}

	req, err := http.NewRequest(method, u, body)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+c.options.Token)
	for _, cb := range cbs {
		cb(req)
	}

	res, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("do request: %w", err)
	}
	return res, nil
}

// get is a generic function that performs a GET request to a Directus
// endpoint and decodes the response payload into a slice of T.
func get[T directusPayloadData](c *Client, endpoint string) ([]T, error) {
	res, err := c.get(endpoint)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	if res.StatusCode != http.StatusOK {
		return nil, util.DecodeDirectusError(res.StatusCode, res.Body)
	}
	return decodePayload[T](res.Body)
}

// decodePayload is a generic function that decodes a Directus payload
// from an io.Reader (e.g. an HTTP response body).
func decodePayload[T directusPayloadData](r io.Reader) ([]T, error) {
	p := &directusPayload[T]{}
	if err := json.NewDecoder(r).Decode(p); err != nil {
		return nil, fmt.Errorf("decode payload: %w", err)
	}
	return p.Data, nil
}

// directusPayload is a generic representation of a Directus payload.
type directusPayload[T directusPayloadData] struct {
	Data []T `json:"data"`
}

// directusPayloadData is an interface that represents the types that can
// be decoded from a Directus payload.
type directusPayloadData interface {
	schema.Collection | schema.Field | schema.Relation
}
