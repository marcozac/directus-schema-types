package dst

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"

	"github.com/marcozac/directus-schema-types/schema"
)

// NewClient creates a new Directus client.
func NewClient(options ClientOptions) *Client {
	return &Client{
		client:  http.DefaultClient,
		options: options,
	}
}

type ClientOptions struct {
	// [REQUIRED]
	// BaseURL is the base URL for the Directus instance.
	BaseURL string

	// [REQUIRED]
	// Token is the authentication token for the client.
	// It must be generated by an admin user.
	Token string
}

// Client is a client for a Directus instance.
type Client struct {
	client  *http.Client
	options ClientOptions
}

// GetSchema returns the schema of the Directus instance.
// Under the hood, it calls GetCollections, GetFields, and GetRelations.
func (c *Client) GetSchema() (*schema.Schema, error) {
	collections, err := c.GetCollections()
	if err != nil {
		return nil, fmt.Errorf("get collections: %w", err)
	}
	fields, err := c.GetFields()
	if err != nil {
		return nil, fmt.Errorf("get fields: %w", err)
	}
	relations, err := c.GetRelations()
	if err != nil {
		return nil, fmt.Errorf("get relations: %w", err)
	}
	return &schema.Schema{
		Collections: collections,
		Fields:      fields,
		Relations:   relations,
	}, nil
}

// GetCollections returns the list of collections in the Directus instance.
func (c *Client) GetCollections() ([]schema.Collection, error) {
	return get[schema.Collection](c, "/collections")
}

// GetFields returns the list of fields in the Directus instance.
func (c *Client) GetFields() ([]schema.Field, error) {
	return get[schema.Field](c, "/fields")
}

// GetRelations returns the list of relations in the Directus instance.
func (c *Client) GetRelations() ([]schema.Relation, error) {
	return get[schema.Relation](c, "/relations")
}

func (c *Client) get(endpoint string) (*http.Response, error) {
	u, err := url.JoinPath(c.options.BaseURL, endpoint)
	if err != nil {
		return nil, fmt.Errorf("join %s endpoint path: %w", endpoint, err)
	}

	req, err := http.NewRequest(http.MethodGet, u, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+c.options.Token)

	res, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("do request: %w", err)
	}
	return res, nil
}

// get is a generic function that performs a GET request to a Directus
// endpoint and decodes the response payload into a slice of T.
func get[T directusPayloadData](c *Client, endpoint string) ([]T, error) {
	res, err := c.get(endpoint)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("status code: %s", res.Status)
	}
	return decodePayload[T](res.Body)
}

// decodePayload is a generic function that decodes a Directus payload
// from an io.Reader (e.g. an HTTP response body).
func decodePayload[T directusPayloadData](r io.Reader) ([]T, error) {
	p := &directusPayload[T]{}
	if err := json.NewDecoder(r).Decode(p); err != nil {
		return nil, fmt.Errorf("decode payload: %w", err)
	}
	return p.Data, nil
}

// directusPayload is a generic representation of a Directus payload.
type directusPayload[T directusPayloadData] struct {
	Data []T `json:"data"`
}

// directusPayloadData is an interface that represents the types that can
// be decoded from a Directus payload.
type directusPayloadData interface {
	schema.Collection | schema.Field | schema.Relation
}
